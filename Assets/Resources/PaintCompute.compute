#pragma kernel BrushPaint;
#pragma kernel SpotPaint;

/*
* Based on:
* https://github.com/SquirrelyJones/Splatoonity/blob/master/Assets/Splatoonity/Shaders/Resources/SplatBlit.shader
*/

Texture2D paint_pattern;
SamplerState linear_clamp_sampler;
RWTexture2D<float4> paintmap;
RWTexture2D<float4> world_pos_tex; //World position mapped to uv1(lightmap) coordinates
RWStructuredBuffer<MATRIX> paint_world_to_object; // Matrix to transform the paint target's world space coordinate to local splat object space
RWStructuredBuffer<float4> scale_bias; // Used to scale(xy) and offset(zw) splat pattern uv coordinates, effectively zooming into the desired pattern
RWStructuredBuffer<float4> paint_channel_mask;
// pass in uv coordinates and worldpos in buffer probably
float2 target_uv; // Target point 
float2 resolution; // Splatmap res

float num_splats;


[numthreads(8,8,1)]
void BrushPaint (uint3 id : SV_DispatchThreadID)
{
    float2 curr_pixel = float2(id.x, id.y);
    
    float4 world_pos = world_pos_tex[curr_pixel];
    
    world_pos = float4(world_pos.xyz,1);  // For matrix multiplication

    for (int i = 0; i < num_splats; i++)
    {
        // Convert world space pos to object space
        float3 obj_pos = mul(paint_world_to_object[i], float4(world_pos.xyz,1)).xyz;

        if(obj_pos.x > -0.5 && obj_pos.x < 0.5 && obj_pos.y > -0.5 && obj_pos.y < 0.5 && obj_pos.z > -0.5 && obj_pos.z < 0.5 )
        {
            float2 uv = saturate( obj_pos.xz + 0.5 ); 
            // Scale and offset splat pattern uvs to only sample the desired pattern from the grid of patterns
            uv *= scale_bias[i].xy;
            uv += scale_bias[i].zw;
            
            // sample the pattern
            float pattern = paint_pattern.SampleLevel(linear_clamp_sampler, uv, 0).x;
            pattern = saturate(pattern - pow( abs( obj_pos.y ),2 )); // falloff around corners
            
            paintmap[curr_pixel] = min( paintmap[curr_pixel], 1.0 - pattern * ( 1.0 - paint_channel_mask[i] ) );
            paintmap[curr_pixel] = max( paintmap[curr_pixel], pattern * paint_channel_mask[i]);
        }
    }
    paintmap[curr_pixel] *= world_pos.w;
}

// Paints an expanding area around the target uv
[numthreads(8,8,1)]
void SpotPaint(uint3 id : SV_DispatchThreadID)
{
    float2 curr_pixel = float2(id.x, id.y);
    // Converts pixel coordinates to uv coordinates
    float2 curr_uv = float2(curr_pixel.x/resolution.x, curr_pixel.y/resolution.y); // Might need to check for D3D11 to flip y

    //float dist = length(curr_uv - target_uv);
    
    // for non-brush: How far is this pixel from the edit point? Use that to determine spread.
    // Set values of colour channels and let surface shader interpolate? Need hard cut-off for each color, no blending
    float4 world_pos = world_pos_tex[curr_pixel];
    
    world_pos = float4(world_pos.xyz,1);  // For matrix multiplication

    for (int i = 0; i < num_splats; i++)
    {
        // Convert world space pos to object space
        float3 obj_pos = mul(paint_world_to_object[i], world_pos).xyz;

        if(obj_pos.x > -0.5 && obj_pos.x < 0.5 && obj_pos.y > -0.5 && obj_pos.y < 0.5 && obj_pos.z > -0.5 && obj_pos.z < 0.5 )
        {
            float2 uv = saturate( obj_pos.xz + 0.5 ); 
            // Scale and offset splat pattern uvs to only sample the desired pattern from the grid of patterns
            uv *= scale_bias[i].xy;
            uv += scale_bias[i].zw;
            
            // sample the pattern
            float pattern = paint_pattern.SampleLevel(linear_clamp_sampler, uv, 0).x;
            pattern = saturate(pattern - pow( abs( obj_pos.y ),2 )); // falloff around corners
            
            paintmap[curr_pixel] = min( paintmap[curr_pixel], 1.0 - pattern * ( 1.0 - paint_channel_mask[i] ) );
            paintmap[curr_pixel] = max( paintmap[curr_pixel], pattern * paint_channel_mask[i]);
        }
    }
}